# Улучшенная версия проверки BST

## Обзор улучшений

Файл `validate_BST_копия.py` содержит улучшенную реализацию проверки бинарного дерева поиска (BST) с учётом замечаний:

### 1. Поддержка дубликатов

**Проблема**: Исходная реализация использует `<=` и `>=`, что полностью запрещает равные ключи.

**Решение**:
- Параметр `allow_duplicates` - разрешить/запретить дубликаты
- Параметр `duplicates_left` - определяет сторону для дубликатов:
  - `True`: дубликаты идут влево (левый потомок может быть `<= parent`)
  - `False`: дубликаты идут вправо (правый потомок может быть `>= parent`)

**Пример**:
```python
#     5
#    / \
#   5   7
is_valid_BST(root, allow_duplicates=True, duplicates_left=True)  # True
```

### 2. None границы вместо ±inf

**Проблема**: Использование `float('-inf')` и `float('inf')` смешивает типы и не подходит для произвольных сравнимых объектов.

**Решение**: Использование `None` для обозначения отсутствия границы.

**Преимущества**:
- Работает с любыми сравнимыми типами (int, float, строки, кастомные классы)
- Не смешивает int и float
- Более явная семантика ("нет границы" vs "бесконечность")

**Пример**:
```python
def validate(node, min_val, max_val):
    if min_val is not None and node.val <= min_val:
        return False
    # ...
```

### 3. Итеративная версия для глубоких деревьев

**Проблема**: На сильно перекошенных деревьях рекурсивная версия может вызвать `RecursionError`.

**Решение**: Функция `is_valid_BST_iterative()` использует in-order обход со стеком.

**Преимущества**:
- Защита от переполнения стека
- Одинаковая временная и пространственная сложность O(n) и O(h)
- Работает на деревьях любой глубины

**Пример**:
```python
# Глубокое дерево из 10000 узлов
root = create_deep_tree(10000)
is_valid_BST_iterative(root)  # Всегда работает
is_valid_BST(root)  # Может вызвать RecursionError
```

## Сравнение реализаций

| Характеристика | Базовая версия | Улучшенная версия |
|---|---|---|
| Дубликаты | Запрещены | Опциональны (слева/справа) |
| Границы | `±inf` (только числа) | `None` (универсально) |
| Глубокие деревья | RecursionError | Итеративная версия OK |
| Сложность | O(n) / O(h) | O(n) / O(h) |

## Использование

### Базовая проверка (без дубликатов)
```python
root = TreeNode(5)
root.left = TreeNode(3)
root.right = TreeNode(7)
is_valid_BST(root)  # True
```

### С дубликатами слева
```python
root = TreeNode(5)
root.left = TreeNode(5)
root.right = TreeNode(7)
is_valid_BST(root, allow_duplicates=True, duplicates_left=True)  # True
```

### С дубликатами справа
```python
root = TreeNode(5)
root.left = TreeNode(3)
root.right = TreeNode(5)
is_valid_BST(root, allow_duplicates=True, duplicates_left=False)  # True
```

### Глубокое дерево
```python
deep_tree = create_very_deep_tree()
is_valid_BST_iterative(deep_tree)  # Безопасно для любой глубины
```

## Запуск тестов

```bash
python test_validate_BST_improved.py
```

Тесты покрывают:
- Базовые случаи (пустое дерево, один узел, валидные/невалидные BST)
- Дубликаты (запрещены, слева, справа, множественные)
- None границы (отрицательные числа, большие числа)
- Глубокие деревья (защита от RecursionError)
- Краевые случаи (нарушения в глубине, граничные значения)

Всего 15 тестов, все успешно проходят.
