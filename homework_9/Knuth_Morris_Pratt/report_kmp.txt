Наивный алгоритм поиска подстроки при несовпадении символов возвращается назад по тексту, 
из-за чего в худшем случае работает за O(n*m).
Алгоритм Кнута—Морриса—Пратта устраняет эту проблему за счёт предварительного анализа паттерна
Он использует информацию о собственных префиксах и суффиксах паттерна, 
чтобы при несовпадении не возвращаться в тексте назад, а сразу сдвигать паттерн на максимально возможную длину.

Если часть паттерна уже совпала, то при несовпадении можно заранее знать, какая его часть всё ещё может совпадать, 
не проверяя символы повторно.

1) Префикс-функция (failure function)

Пусть pattern — строка длины m.
Префикс-функция pi[i] определяется как длина наибольшего собственного префикса строки pattern[:i+1], который одновременно является её суффиксом.

Собственный префикс — префикс, не равный всей строке целиком.

Как строится pi (алгоритм строит его за один проход):
- поддерживается переменная k — длина текущего совпавшего префикса
- если следующий символ совпадает, k увеличивается
- если не совпадает происходит откат к pi[k-1], пока не найдётся подходящее совпадение или k не станет равным 0

Каждый символ паттерна обрабатывается константное число раз, поэтому построение pi работает за O(m).

2) Алгоритм поиска

После вычисления префикс-функции происходит поиск по тексту.

Поддерживается переменная k — количество уже совпавших символов паттерна.

Для каждого символа текста:
1.	если символ не совпадает с pattern[k], выполняется откат k = pi[k-1]
2.	если совпадает — k увеличивается
3.	если k == m, найдено полное вхождение паттерна:
    - индекс начала равен i - m + 1
    - затем k откатывается к pi[k-1], чтобы искать перекрывающиеся вхождения

Указатель по тексту никогда не движется назад.

3) Почему алгоритм работает за линейное время?

- индекс i по тексту увеличивается от 0 до n-1 ровно один раз
- значение k может увеличиваться и уменьшаться, но суммарное число его изменений ограничено длиной строки.

Каждый символ текста и паттерна либо увеличивает k, либо уменьшает его через pi и не участвует в сравнении повторно.

ОЦЕНКА СЛОЖНОСТТИ:

Временная сложность = Построение префикс-функции O(m) + Поиск по тексту O(n) 
Итого O(n + m) даже в худшем случае

Пространственная сложность в основном состоит из хранения массива pi длины m O(m) (+ несколько вспомогательных переменных)
Итого O(m)