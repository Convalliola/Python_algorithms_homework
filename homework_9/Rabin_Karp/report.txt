Идея: хеш подстроки длины m считаются как полином по основанию d по модулю q.

Для строки s[0..m-1]:
H(s)= (s_0 * d^{m-1} + s_1 * d^{m-2} + ...+ s_{m-1} * d^0) % q
где s_i — числовое значение символа (в коде ord(s[i])), 
d - основание полиномиального хеша (число, с помощью которого строка кодируется в одно число)
q - большое простое число, которое используется, чтобы ограничивать рост чисел
(иначе хеши станут огромными), работать в кольце вычетов, уменьшать вероятность коллизий.

Почему rolling hash (скользящий):
Когда окно сдвигается на 1 вправо, пересчитывать хеш с нуля дорого (O(m)). Вместо этого обновляем за O(1):

Пусть есть хеш окна text[i : i+m], тогда для следующего окна text[i+1 : i+m+1]:
1.	вычитаем вклад уходящего слева символа text[i] * d^{m-1}
2.	сдвигаем оставшееся, умножив на d
3.	добавляем новый символ справа

Формула как в коде:
H_{i+1} = (d * (H_i - text[i]\ * d^{m-1}) + text[i+m]) mod q

В коде заранее считается h = pow(d, m-1, q) чтобы быстро удалять левый символ: ord(text[i]) * h

Разные строки могут иметь одинаковый хеш по модулю q, 
поэтому при равенстве хешей делается точная проверка text[i:i+m] == pattern.

ОЦЕНКА СЛОДНОСТИ:

n = len(text)
m = len(pattern)

Время:
- Предварительный расчёт хешей: O(m)
- Проход по всем окнам: n-m+1 шагов, на каждом шаге обновление хеша O(1)
- При совпадении хешей делается сравнение строк длины m: O(m)

Выходит что:
- ожидаемая/средняя сложность: O(n+m) (если коллизий мало, проверки редкие)
- худший случай: O(n*m) (если хеш совпадает часто/всегда и каждый раз идёт проверка)

Память - O(1) дополнительной памяти, не считая списка результатов